# README

The stream-controller micro-service tracks the number of streams that users are watching and prevents more 
than three being watched concurrently. 

## Build

The service can be easily built using the following commands:

```
dep ensure --vendor-only
go build -o stream-controller cmd/main.go
``` 

The dependency management is handled by `dep`. It is available [here](https://github.com/golang/dep).
These commands will produce the executable ELF file `stream-controller` that can be run in the usual manner.

### Tests

The unit tests have been provided and are run from the project directory with: 

```
go test ./internal/...
```  

These unit tests make use of mock objects generated by gomock. The generated code can be regenerated by running
the `mocks.sh` bash script from the project directory.

Note that the `end_to_end_test.go` file in `testing/` directory is designed to be run against a running server.    

## Configuration

The service has been written to read its configuration from a Consul service KV store. The `startup.sh` script found in
the `dev` directory starts up a Consul server in development mode within a locally running docker container. The sample
configuration in `config.json` is added to the KV store once the server is running. The `shutdown.sh` script is used to 
shutdown the Consul server when finished running the service locally. These script assume that `docker` and 
`docker-compose` are installed. 

The two environment variables `CONSUL_ADDRESS` and `CONSUL_KEY` determine the address of the Consul server and the key 
under which the configuration for this service is stored. If these are not provided then the default values of 
`http://localhost:8500` and `services/stream-control` are used.

## How To Use

The service exposes three RESTful endpoints. The HTTP method and path are given below: 

* PUT: `/v1/users/{userID}/streams/{streamID}` records the user watching the stream. If the user has not exceeded 
their quota then `Created` is returned, otherwise `Bad Request` is returned. 
* DELETE: `/v1/users/{userID}/streams/{streamID}` records the user as having finished watching that stream. This will
return a `OK` response.
* GET: `/v1/users/{userID}` will return a comma-separated list of the streams being watch by that user with a `OK` 
response code.

Any errors returned by the persistence layer will return `Internal Server Error` responses and will also be logged. 

## Storage and Scalability

The details of the users viewing habits are persisted to a Redis server. The `docker-compose.yml` locally runs a
containerised Redis server taken from DockerHub. Multiple servers behind a load balancer may share the same Redis 
server without any special considerations. If a single server becomes overloaded then moving to a Redis cluster
is a possibility. 
